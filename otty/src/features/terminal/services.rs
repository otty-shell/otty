use std::path::{Path, PathBuf};
use std::{env, fs};

use otty_ui_term::settings::{LocalSessionOptions, SessionKind, Settings};

use super::errors::TerminalError;
use super::model::ShellSession;
use crate::state::State;

const SHELL_INTEGRATIONS_DIR: &str = "otty";

const OTTY_ZSH_SCRIPT: &str =
    include_str!("../../../../assets/shell-integrations/otty.zsh");
const OTTY_BASH_SCRIPT: &str =
    include_str!("../../../../assets/shell-integrations/otty.bash");

/// Build a shell session configured with OTTY integrations for a given shell.
pub(crate) fn setup_shell_session_with_shell(
    shell_path: &str,
) -> Result<ShellSession, TerminalError> {
    let shell_name = shell_name(shell_path);

    let dir = config_dir();
    fs::create_dir_all(&dir)?;

    let session = match shell_name.as_str() {
        "zsh" => setup_zsh_session(shell_path, &dir)?,
        "bash" => setup_bash_session(shell_path, &dir)?,
        _ => {
            let options =
                LocalSessionOptions::default().with_program(shell_path);
            SessionKind::from_local_options(options)
        },
    };

    Ok(ShellSession::new(shell_name, session))
}

/// Build a shell session without writing shell integration files for a shell.
pub(crate) fn fallback_shell_session_with_shell(
    shell_path: &str,
) -> ShellSession {
    let shell_name = shell_name(shell_path);
    let options = LocalSessionOptions::default().with_program(shell_path);

    ShellSession::new(shell_name, SessionKind::from_local_options(options))
}

/// Clone terminal settings with a session descriptor for terminal startup.
pub(crate) fn terminal_settings_for_session(
    base_settings: &Settings,
    session: SessionKind,
) -> Settings {
    let mut settings = base_settings.clone();
    settings.backend = settings.backend.clone().with_session(session);
    settings
}

fn shell_name(shell_path: &str) -> String {
    Path::new(shell_path)
        .file_name()
        .and_then(|name| name.to_str())
        .map(ToString::to_string)
        .unwrap_or_else(|| shell_path.to_string())
}

fn config_dir() -> PathBuf {
    if let Ok(home) = env::var("HOME") {
        return Path::new(&home)
            .join(".config")
            .join(SHELL_INTEGRATIONS_DIR);
    }

    env::temp_dir().join(SHELL_INTEGRATIONS_DIR)
}

fn setup_zsh_session(
    shell_path: &str,
    dir: &Path,
) -> std::io::Result<SessionKind> {
    let original_zdotdir = env::var("ZDOTDIR").ok();

    let script_path = dir.join("otty.zsh");
    fs::write(&script_path, OTTY_ZSH_SCRIPT)?;

    let zshrc_path = dir.join(".zshrc");
    let zshrc_contents = r#"
# Generated by OTTY: wrapper around user zshrc
if [[ -n "${OTTY_ORIG_ZDOTDIR:-}" && "${OTTY_ORIG_ZDOTDIR}" != "${ZDOTDIR:-$HOME}" && -f "${OTTY_ORIG_ZDOTDIR}/.zshrc" ]]; then
  source "${OTTY_ORIG_ZDOTDIR}/.zshrc"
elif [[ -f "${HOME}/.zshrc" ]]; then
  source "${HOME}/.zshrc"
fi

if [[ -f "${ZDOTDIR:-$HOME}/otty.zsh" ]]; then
  source "${ZDOTDIR:-$HOME}/otty.zsh"
fi
"#;

    fs::write(&zshrc_path, zshrc_contents.trim_start())?;

    let dir_str = dir.to_string_lossy();
    let mut options = LocalSessionOptions::default()
        .with_program(shell_path)
        .with_env("ZDOTDIR", dir_str.as_ref());

    if let Some(value) = original_zdotdir {
        if Path::new(&value) != dir {
            options = options.with_env("OTTY_ORIG_ZDOTDIR", &value);
        }
    }

    Ok(SessionKind::from_local_options(options))
}

fn setup_bash_session(
    shell_path: &str,
    dir: &Path,
) -> std::io::Result<SessionKind> {
    let script_path = dir.join("otty.bash");
    fs::write(&script_path, OTTY_BASH_SCRIPT)?;

    let wrapper_path = dir.join("otty.bashrc");
    let script_path_display = script_path.to_string_lossy();
    let wrapper_contents = format!(
        r#"# Generated by OTTY: wrapper around user bashrc
if [[ -f "$HOME/.bashrc" ]]; then
  source "$HOME/.bashrc"
fi

if [[ -f "{script_path_display}" ]]; then
  source "{script_path_display}"
fi
"#
    );

    fs::write(&wrapper_path, wrapper_contents.trim_start())?;

    let wrapper_path = wrapper_path.to_string_lossy().into_owned();
    let options = LocalSessionOptions::default()
        .with_program(shell_path)
        .with_args(vec!["--rcfile".to_string(), wrapper_path]);

    Ok(SessionKind::from_local_options(options))
}

/// Resolve current working directory from active shell terminal tab.
pub(crate) fn shell_cwd_for_active_tab(state: &State) -> Option<PathBuf> {
    let tab_id = state.active_tab_id()?;
    let terminal = shell_terminal_tab(state, tab_id)?;
    terminal
        .focused_terminal_entry()
        .and_then(|entry| terminal_cwd(&entry.terminal.blocks()))
}

fn shell_terminal_tab(
    state: &State,
    tab_id: u64,
) -> Option<&super::state::TerminalTabState> {
    state
        .terminal_tab(tab_id)
        .filter(|terminal| terminal.is_shell())
}

fn terminal_cwd(blocks: &[otty_ui_term::BlockSnapshot]) -> Option<PathBuf> {
    blocks
        .iter()
        .rev()
        .find_map(|block| block.meta.cwd.as_deref())
        .map(PathBuf::from)
}

#[cfg(test)]
mod tests {
    use std::path::PathBuf;
    use std::time::{SystemTime, UNIX_EPOCH};
    use std::{fs, process};

    use otty_ui_term::settings::SessionKind;

    use super::{
        fallback_shell_session_with_shell, setup_bash_session,
        setup_zsh_session,
    };

    struct TempDirGuard {
        path: PathBuf,
    }

    impl TempDirGuard {
        fn new(prefix: &str) -> Self {
            let stamp = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .expect("system time should be after epoch")
                .as_nanos();
            let path = std::env::temp_dir().join(format!(
                "otty-terminal-{prefix}-{}-{stamp}",
                process::id(),
            ));
            fs::create_dir_all(&path)
                .expect("failed to create temporary directory");
            Self { path }
        }
    }

    impl Drop for TempDirGuard {
        fn drop(&mut self) {
            let _ = fs::remove_dir_all(&self.path);
        }
    }

    #[test]
    fn given_shell_path_when_fallback_session_created_then_uses_local_program()
    {
        let session = fallback_shell_session_with_shell("/usr/bin/bash");

        assert_eq!(session.name(), "bash");
        match session.session() {
            SessionKind::Local(options) => {
                assert_eq!(options.program(), "/usr/bin/bash");
            },
            SessionKind::Ssh(_) => {
                panic!("expected local session kind");
            },
        }
    }

    #[cfg(unix)]
    #[test]
    fn given_temp_dir_when_setup_bash_session_then_wrapper_files_are_written() {
        let temp_dir = TempDirGuard::new("bash");
        let session =
            setup_bash_session("/bin/bash", &temp_dir.path).expect("setup");

        let script_path = temp_dir.path.join("otty.bash");
        let wrapper_path = temp_dir.path.join("otty.bashrc");
        assert!(script_path.exists());
        assert!(wrapper_path.exists());

        match session {
            SessionKind::Local(options) => {
                assert_eq!(options.program(), "/bin/bash");
                assert_eq!(options.args().len(), 2);
                assert_eq!(options.args()[0], "--rcfile");
                assert_eq!(options.args()[1], wrapper_path.to_string_lossy());
            },
            SessionKind::Ssh(_) => {
                panic!("expected local session kind");
            },
        }
    }

    #[cfg(unix)]
    #[test]
    fn given_temp_dir_when_setup_zsh_session_then_wrapper_files_are_written() {
        let temp_dir = TempDirGuard::new("zsh");
        let session =
            setup_zsh_session("/bin/zsh", &temp_dir.path).expect("setup");

        let script_path = temp_dir.path.join("otty.zsh");
        let zshrc_path = temp_dir.path.join(".zshrc");
        assert!(script_path.exists());
        assert!(zshrc_path.exists());

        match session {
            SessionKind::Local(options) => {
                assert_eq!(options.program(), "/bin/zsh");
                let zdotdir = options.envs().get("ZDOTDIR");
                assert_eq!(
                    zdotdir,
                    Some(&temp_dir.path.to_string_lossy().to_string()),
                );
            },
            SessionKind::Ssh(_) => {
                panic!("expected local session kind");
            },
        }
    }
}
